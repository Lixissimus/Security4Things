% v2-acmtog-sample.tex, dated March 7 2012
% This is a sample file for ACM Transactions on Graphics
%
% Compilation using 'acmtog.cls' - version 1.2 (March 2012), Aptara Inc.
% (c) 2010 Association for Computing Machinery (ACM)
%
% Questions/Suggestions/Feedback should be addressed to => "acmtexsupport@aptaracorp.com".
% Users can also go through the FAQs available on the journal's submission webpage.
%
% Steps to compile: latex, bibtex, latex latex
%
% For tracking purposes => this is v1.2 - March 2012
\documentclass{sig-alternate} % v 2.5

% --- Author Metadata here ---
\conferenceinfo{Sample Conference}{'15 Potsdam, Germany}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\begin{document}

\title{Project Light}

\numberofauthors{5}

\author{
\alignauthor
Cornelius Bock
%
\alignauthor
Daniel Werner
%
\alignauthor
Felix Wolff
%
\and
\texttt{\{cornelius.bock|daniel.werner|felix.wolff\}@student.hpi.de} \\ \\
\and
\alignauthor
Prof. Dr. Christoph Meinel\\
    \affaddr{\textit{Supervisor}}
%
\alignauthor
Konrad-Felix Krentz\\
    \affaddr{\textit{Supervisor}}
}

\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
\end{abstract}

\category{K.6.5}{Management Of Computing And Information Systems}{Security}

\terms{Internet of Things, Security}

\keywords{Internet of things, security, key transmission, light}

\section{Introduction}
\label{sec:introduction}

The Internet of Things (IoT) is becoming more and more reality every day.
It consists of small devices (called \textit{motes}), which are connected to the public Internet.
They work together, allowing monitoring and controlling of several kinds of real-world systems. % SOURCE!
E.g., motes collecting information about parking lot occupancy allowing car drivers to find free spaces using their smart phones\footnote{see http://www.streetline.com/}.

In the last decades, the rise of embedded systems changed daily lives. % Source?
However, these systems often had limited networking capabilities or at least used their own, proprietary and thus unaccessible network technology.
Because of the huge variety of valuable possibilities, the impact of embedded systems will be advanced even further within the IoT.

However, this comes at a price: by being accessible from the Internet, the attack surface of such systems is much larger than that of traditional embedded systems.
New, adapted security measurements had to be developed and implemented to react to this.
For example, Adaptive Key Establishment Scheme (AKES) provides adaptable security measures for being used with the IEEE~802.15.4 network stack, which is commonly used by IoT devices. % SOURCE!
Nevertheless, one problem remains: IoT setups usually consist of plentiful nodes which all need to be initialized with keying material and parameters.
This is a major problem, because typical motes lack of input/output devices which are securely usable without configured networking.

% figure is inserted here to be shown on page 1
\begin{figure}
	\centering
	\includegraphics[scale=.4]{images/overview.png}
	\caption{Transmission of keying material with light: \textbf{a)} enter and encode key and parameters on smart phone, \textbf{b)} transmit them via light to the mote, \textbf{c)} persist key and parameters, \textbf{d)} communicate securely via the public Internet }
	\label{fig:overview}
\end{figure}

One possibility is to plug a wire to each and every node in order to initialize it.
However, there are two downsides: first, a typical IoT setup consist of too many devices to be plugging a feasible solution. Second, in most installations, attackers may have physical access to motes, so jacks on the mote (e.g. JTAG) are a dangerous security threat.

Another approach is to pre-initialize the keys in the factory.
This would mean that either there is a small set of assigned keys, which would lead to vulnerabilities to brute-force attacks; or each mote gets an individual key, which requires a secure transmission and attribution of keys to motes\footnote{This would also increase cost of motes, but they need to be as cheap as possible in order to be affordable in great numbers.}.
Anyway, pre-initialization requires somebody other than the user/installer to know the keys, which diminishes security.

This paper proposes an alternative way, which is transmitting initial keying material via light.
It is mainly targeted on private users without technical background and should provide them with a simple though secure process for initializing.

As to be seen in fig.~\ref{fig:overview}, the user utilizes a smart phone application to enter, encode and emit keying material using the flash light of the phone.
The mote receives the message via a light sensor and reconstructs the keys.
After successful initialization and verification, the mote saves the keying material permanently.
On subsequent reboots, it is read from memory and immediately usable without any further action required.

There are several advantages of this method.
Light sensors are smaller and less misusable than jacks.
The physics of light is well understood by non-technical people, in contrast to radio waves.
Thus, leaking of the wireless sent secrets is less likely.
Moreover, multiple devices could be initialized concurrently by just placing them next to each other.

We implemented a prototype for an Android smart phone and a mote running the Contiki OS, \cite{dunkels04contiki}.
Contiki is an open source, state-of-the-art operating system for IoT devices\footnote{http://www.contiki-os.org/}.
We also tested some techniques to make the transmission error-prone.
Besides, we examined how fast the whole transmission could become while maintaining a high chance of correctness.

The rest of the paper is structured as follows:
Section~\ref{sec:related_work} contains some background for security in the context of the~IoT and alternative approaches for key initialization.
In section~\ref{sec:communication_protocol}, we propose our protocol for the smart phone and the mote to communicate via light.
Details of our implementations are presented in section~\ref{sec:implementation}, both for the emitting~(sec.~\ref{sub:android_app}) and the receiving~(sec.~\ref{sub:mote}) parts.
In section~\ref{sec:results_and_discussion}, we discuss our findings regarding the protocol and it's limits.
We conclude our work and give an outlook on what could be done next in section~\ref{sec:future_work}.


\section{Background and Related Work}
\label{sec:related_work}

In order to make the IoT reality, a specialized network stack is needed.
Motes have special constrains regarding energy and memory resources, e.g. batteries should work for multiple years and a mote's program memory will be very small (e.g. 48kb program flash for telosB mote, \cite{telosb}).
Additionally, typical IoT setups will make use of hundreds of nodes, so there many more addresses needed than the traditional Internet uses.

The \textit{IPv6 over Low-Power Wireless Personal Area Networks (6LoWPAN)} protocol stack as described in \cite{palattella2013standardized} is tailoring this needs.
The criteria for IoT network stacks are according to them: low power usage, high reliability, Internet-suitability.
Therefore, tailored implementations of stack layers are presented, like \textit{PHY of IEEE 802.15.4}, which is a power saving physical/link layer.
In order to be Internet-enabled regarding the need for huge amounts of addresses, IPv6 is utilized.
However, in order to save energy, the headers of IPv6 packets are heavily compressed in 6LoWPAN.

There are some proposals for specialized security measures in this stack, e.g. \textit{Adaptive Key Establish- ment Scheme (AKES)}, \cite{krentz15akes}.
AKES makes use of session keys and a neighborhood-exploration-technique to gain sufficient security level while being memory-space-saving.
Security is even obtained after reboots.
It still relies on predistribution keys on each mote.

The problem of wireless and user-friendly key predistribution / key provisioning remains.
There are multiple approaches to solve this:

\begin{itemize}
	\item \cite{chen2011over} proposes key provisioning using eliptic curve cryptography (ECC). However, while meeting high security standards, software implementations of ECC require a lot of memory space and energy while hardware implementations increase the per-unit cost.
	\item In order to secure radio communication, \cite{kuo2007message} utilizes a Faraday cage in which a mote can be programmed without interleaving of messages from an attacker outside of the cage. Additionally, a third device outside of the cave jams radio waves to prevent malicious communication.
	\item \textit{6doku} is a protocol for pairing  a mote with a touch-enabled devices like an smart phone, \cite{krentz20156doku}. The smart phone needs extra hardware attached for communicating with the mote via radio waves. It relies on interaction with the end-user, e.g. he needs to check if blinking on the screen happens in sync with him pressing a button on the mote.
\end{itemize}

- some ideas to transmit keys via light:

- Blink 'Em All \cite{saxena2009blink} lets motes LEDs blink and computer with connected camera read it.

- LiDSN \cite{doan2012lidsn} same with special connector-hardware where mote gets put into. if mote has no led, light sensor is assumed and connector emits light. Proved as usable by end-user, but special hardware needed

- Electric Imp \cite{electricimp} sells proprietary BlinkUp technology: uses smart phone for flickering -> good for end users
- not scientifically examined till now (as far as we know)

thus, we propose a user-friendly wireless key provisioning protocols without additional hardware needed, just mote with light sensor and smart phone.

\section{Communication Protocol}
\label{sec:communication_protocol}

In the following section, we describe the phases of the protocol.
Each phase contains the necessary steps for the Android device and the mote.
Insights into the concrete implementation will be given in the Section~\ref{sec:implementation}.

\subsection{Calibration}
\label{sub:calibration}

The goal of the calibration phase is to establish light values for \textit{bright} and \textit{dark} on the mote.
By doing this in the beginning of the protocol, we can adapt to different lighting situations in the room and different brightness levels of the phone.

The task of the phone in this protocol stage is simple.
It periodically sends \textit{bright} and \textit{dark} values, each with a certain period length $T$.
Simply said, it is blinking.

The mote on the other side measures $n$ light values using its light sensor.
The time between two measurements will probably not be equal to $T$, because the period length is unknown to the mote at this point.
As long as \textit{bright} and \textit{dark} values are part of the $n$ measurements, the concrete time does not matter.
After reading $n$ values, the mote calculates reasonable numeric values for \textit{bright} and \textit{dark}.
For instance, this can be achieved by applying a \mbox{\textit{2-means}} algorithm, see Section~\ref{ssub:contiki_process}.
After that, the mote is able to classify new light values.
In other words, it can read bits.

\subsection{Synchronization}
\label{sub:synchronization}

During synchronization, the mote learns the period length $T$.
This is necessary to be able to read light values at the right time (see Figure~\ref{fig:read_a_bit}).

In this phase, the phone just keeps sending \textit{bright} and \textit{dark} values with the period length $T$.
This is the same as during calibration.

The mote on the other hand now measures light values as fast as it can and classifies them as \textit{0} and \textit{1}.
Once it notices that the bit flips, it records the time when the switch happened.
After recording $m$ bit flips, it can calculate the average period length.

With completion of the first two phases, the mote is now able to read data sent by the phone.
It learned a decision threshold for decoding the bits and the period length to read values at the right time.
Figure~\ref{fig:read_a_bit} shows how data can be read.
However, the actual implementation slightly differs from that figure, see Section~\ref{sec:implementation}.

\begin{figure}
	\centering
	\includegraphics[scale=.5]{images/reading_data.png}
	\caption{Reading data: The black horizontal lines show the brightness emitted by the phone, the red line is the decision threshold for classifying \textit{0} and \textit{1}. Each arrow shows a point in time where the mote reads the value of the light sensor. The result here is the bit string 0111.}
	\label{fig:read_a_bit}
\end{figure}

\subsection{Initialization}
\label{sub:initialization}

The target of the initialization phase is to tell the mote, when the actual data starts.
The communication between the mote and the phone is one-way.
That means, the mote cannot communicate with the Android app.
Therefore, the app has to guess, when the mote has successfully done calibration and synchronization.
This can either be done by using a fixed time (let's say the app stays in calibration and synchronization phase for 10 seconds), or by user interaction (the user presses a button, when the mote indicates that it's ready).

When the phone reaches the initialization phase as a result of one of those methods, it sends a pre-defined initialization pattern.
The pattern must be different from 0101... and needs to have a length of one binary encoded character, e.g. 8 bit for ASCII encoding.
It sends the pattern exactly once, then it proceeds to the next phase.

After successful synchronization, the mote waits for the initialization pattern.
It does that by reading single bits and comparing the last 8 bits (for ASCII encoding) to the pre-defined pattern.
Once the init pattern has been detected, the mote immediately switches to the data sending phase.

\subsection{Data sending}
\label{sub:data_sending}

In the data sending phase, we can finally transmit the data packet.
As we can see in Figure~\ref{fig:data_packet}, the packet contains the data length, the actual data and a checksum used for validation of the received data in the validation phase~\ref{sub:validation}.

The Android app encodes the data string (e.g. ASCII encoding), measures its binary length and calculates the checksum using a pre-defined checksum algorithm.
It is obvious, that those calculations can be done beforehand.
The concatenated bit string then is sent using flashing of the display or the flash light.

The mote, after having recognized the initialization pattern, reads blocks of bits.
The first 4 byte are interpreted as the length of the actual data.
Afterwards, it reads the appropriate number of blocks to receive the data workload.
Once the whole data workload is read, it interprets the last 4 byte as the checksum.

\begin{figure}
	\centering
	\includegraphics[scale=.3]{images/data_packet.png}
	\caption{Contents of the data packet: Besides the actual data, there is also the data length and a checksum transmitted.}
	\label{fig:data_packet}
\end{figure}

\subsection{Validation}
\label{sub:validation}

In this last phase, the mote checks whether the transmission was successful.
The phone does nothing in this phase, it has successfully run the protocol.
The mote uses the received data workload and calculates the checksum by itself.
If it is equal to the received one, the data packet is considered to be transmitted correctly.
If both checksums differ, something must have gone wrong.
It is not clear, whether the data workload was transmitted correctly and therefore the mote goes into an error state.

\section{Implementation}
\label{sec:implementation}

Project Light consists of an Android app that creates and sends the keying material and a Contiki process that runs on the TelosB sky mote and receives and validates it, \cite{dunkels04contiki}, \cite{telosb}.
Both follow the aforementioned communication protocol very closely, but increase reliability and fail-safeness through the following design decisions.

All data that is being sent is encoded using a \textit{Hamming(8,4)-code} so that two-bit errors can be detected and one-bit errors can be corrected.

The \textit{CRC32} is chosen as the checksum algorithm for the validation phase to avoid saving erroneous key material.
This could be caused by 3-or-more-bit errors that the Hamming-code failed to detect.

As the android timer that triggers the bit emission cannot be too early but in fact tends to be a little late\cite{mongia2010reliable}, the time at which the mote reads a bit is not in the middle of a period as suggested by Figure~\ref{fig:read_a_bit}.
It is at the very end of a period to maximize error avoidance due to timer delays\footnote{The Contiki timer that triggers the reading of the bit is a real-time timer.}.

In the following sections, both the implementation of the Android application and the Contiki process are described in more detail.

\subsection{Android app}
\label{sub:android_app}

We have developed two different versions of the Android application for users to enter keys and transmit them.

% Ich wuerde den gesamten folgenden Abschnitt weglassen und gar nicht so richtig ueber die js timer Sachen reden. Vielleicht lieber noch einen kurzen Abschnitt generell ueber timing Sachen?

The first version is written using web technologies (i.e. HTML, CSS, and JavaScript) and deployed to the smart phone using Apache~Cordova\footnote{https://cordova.apache.org/}.
Because of this, the application can also run in most desktop browsers and can easily be ported to work with other smart phone operating systems, too, e.g. iOS or Windows Phone 8.1.
In this version, almost all parameters for the transmission are adjustable by the user: length of one bit, length of initialization phase, initialization-pattern, start-pattern, if hamming-encoding should be used.
Therefore it is convenient to experiment with various settings and transmission parameters and to test of the Contiki process.
There are two disadvantages of this implementation, which motivated us to build a second edition:
First, experiments using the flash light for light emission showed, that there are no predictable timing behavior, e.g. the flash light was simply to slow to allow short transmission times.
This forced us to use the screen for light emission, which resulted in far smaller brightness margins to be read by the mote.
Secondly, in order to get reliable transmission quality, we need to become as close to real-time as possible.
This technology stack indicates bad real-time behavior, i.g. the Cordova runtime and the JavaScript interpreter could be omitted.

% bis hier hin weg

\begin{figure}
	\centering
	\includegraphics[scale=.15]{images/screen_native.png}
	\caption{Screenshot of the native Android application used to encode the key and emit it as light flickering.}
	\label{fig:screenshot}
\end{figure}

% Und den dann natuerlich noch anpassen

Hence, we built a native Android application written in Java.
Still on Android, it is impossible to guarantee real-time behavior, but we may get smaller delays without JavaScript involved.
The Java implementation also benefits from the ability of the native Java timer to re-adjust itself, which means that timing errors do not add up.
In that way, the phone and the mote do not get out of sync, no matter how long the transmission takes.
% , e.g. if one event is fired too late such as wrong bit gets transmitted, the delay does not add up for the next bit.
This comes hand-in-hand with the Hamming(8,4)-encoding we used, because this could fix potential one-bit-errors in each byte.
Another advantage of this version is the flash light.
Depending on the smart phone model, the flash light was as fast as screen flickering even for small bit lengths, while being much brighter.
Especially when attempting to program multiple motes at once this comes very handy.
To improve usability and discoverability, we dropped controls for some parameters, which led to a much leaner design as shown in figure~\ref{fig:screenshot}.

However, as discussed in section~\ref{sec:results_and_discussion}, both versions worked well with similar values for the length of one bit.

\subsection{Mote}
\label{sub:mote}

The implementation on the mote is divided into two parts.
The communication protocol and key storage is implemented in a Contiki process.
For the mote to securely communicate, the link layer needs to be initialized using the transmitted key, which is accomplished by a link layer driver wrapper.

\subsubsection{Contiki process}
\label{ssub:contiki_process}

The \textit{light process} implements the receiving side of the communication protocol.
A real-time timer called \textit{rtimer}, which is offered by the Contiki operating system, eliminates timer inaccuracies on the mote side.
The mote uses its light sensor to sense the current brightness.
Once the process is started, an LED-countdown (red -> blue -> green) indicates the start of the key initialization procedure.
A \mbox{\textit{2-means}} algorithm is used to create two clusters of \textit{bright} and \textit{dark} values and to compute their mean values~(\ref{sub:calibration}).
Subsequently a new value is classified as \textit{0} or \textit{1} depending on which mean value is closer to it.
After the successful calibration, synchronization and initialization a blue LED indicates that the mote is receiving data.
If an error is detected by the Hamming-code or if the computed checksum does not match the transmitted one, a red LED indidcates the failure and the process should be restarted.
A green LED shows that the key material has successfully been received and was saved to the permanent flash memory of the mote.


\subsubsection{Contiki driver wrapper}
\label{ssub:contiki_driver_wrapper}

For the mote to actually use the key material that was transmitted, the initialization of the link layer security needs to be delayed until the key transmission finished successfully.
To do so we created a link layer driver wrapper that accomplishes the following things:

\begin{enumerate}
	\item Delay all calls to the link layer driver.
	\item Check whether the key material was initialized before.
	\item If not, start the \textit{light process} and wait for successful key transmission.
	\item Initialize the link layer using the transmitted key material.
	\item Forward all calls to the link layer driver.
\end{enumerate}

Calls to the driver that are being issued before the key material initialization are actually being canceled right now, but should eventually just be delayed and reissued once the initialization has finished.
Including the light app on a mote automatically redefines \textit{NETSTACK\_CONF\_LLSEC}\footnote{This global constant defines the link layer driver that is used by the mote.} to point to our link layer driver wrapper.
On the first start of the mote the key initialization via the \textit{light process} is triggered whereas during later starts the mote recognizes that its key material has been initialized before.

\section{Results and Discussion}
\label{sec:results_and_discussion}

Having a configurable transmission rate was very helpful during development and testing.
However it certainly introduces possible errors as the mote has to recognize the correct transmission rate, otherwise the initialization procedure will fail.
We decided against fixating it, as during our experiments the mote in all cases determined the correct transmission rate.
Also while testing different Android phones, we noticed each of it works best with a different transmission rate, so the app should change it depending on the phone model.

\begin{itemize}
	\item measure and evaluate maximum transmission speed, error rate
	\item is hamming code necessary (worth the doubled length) or CRC alone sufficient
\end{itemize}



\section{Conclusion and Future Work}
\label{sec:future_work}

In this paper, we presented a secure method for IoT-device initialization by transmitting initial keying material via light.
It is mainly targeted at private users and can easily be executed having no technical background at all.

Future work should target the further automation of the presented process, by establishing a bidirectional communication.
Using its camera the mobile phone could detect the current LED-state of the mote and react accordingly, e.g. start the data transmission or restart the whole process.

To simplify the initialization of several motes at once, two things need be done.
First, the app should stay in calibration and synchronization phase, until the user presses a button.
Second, the mote should indicate via an LED that it reached the initialization phase~(\ref{sub:initialization}).
With those two concepts, the key transmission to several motes could work as follows:
The user lays out all motes in a grid next to each other.
Then the phone is placed on top of them and the app is started.
All motes are placed, so that they receive the flickering of the phones flash light.
The motes are started one after another.
Once the motes are running, the user waits for all of them to indicate via an LED, that they reached the initialization phase.
They are now all waiting for the initialization pattern.
The user presses a button in the app and the phone sends the initialization pattern followed by the data packet.
When the transmission is over, the user can see via a red LED which motes failed to receive the data correctly.
The process needs to be restarted with those motes.


% den Satz verstehe ich nicht
User-friendliness should be prioritized as success and adoption of this presented additional security measure will greatly benefit from it.


% Bibliography
\bibliographystyle{ACM-Reference-Format-Journals}
\bibliography{paper}

\end{document}
